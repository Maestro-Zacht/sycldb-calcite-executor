/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "calciteserver_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kRelNodeTypeValues[] = {
  RelNodeType::TABLE_SCAN,
  RelNodeType::FILTER,
  RelNodeType::JOIN,
  RelNodeType::PROJECT,
  RelNodeType::AGGREGATE,
  RelNodeType::SORT
};
const char* _kRelNodeTypeNames[] = {
  "TABLE_SCAN",
  "FILTER",
  "JOIN",
  "PROJECT",
  "AGGREGATE",
  "SORT"
};
const std::map<int, const char*> _RelNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kRelNodeTypeValues, _kRelNodeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const RelNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _RelNodeType_VALUES_TO_NAMES.find(val);
  if (it != _RelNodeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RelNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _RelNodeType_VALUES_TO_NAMES.find(val);
  if (it != _RelNodeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDirectionOptionValues[] = {
  DirectionOption::DESCENDING,
  DirectionOption::ASCENDING
};
const char* _kDirectionOptionNames[] = {
  "DESCENDING",
  "ASCENDING"
};
const std::map<int, const char*> _DirectionOption_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDirectionOptionValues, _kDirectionOptionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DirectionOption::type& val) {
  std::map<int, const char*>::const_iterator it = _DirectionOption_VALUES_TO_NAMES.find(val);
  if (it != _DirectionOption_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DirectionOption::type& val) {
  std::map<int, const char*>::const_iterator it = _DirectionOption_VALUES_TO_NAMES.find(val);
  if (it != _DirectionOption_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNullsOptionValues[] = {
  NullsOption::FIRST,
  NullsOption::LAST
};
const char* _kNullsOptionNames[] = {
  "FIRST",
  "LAST"
};
const std::map<int, const char*> _NullsOption_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kNullsOptionValues, _kNullsOptionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const NullsOption::type& val) {
  std::map<int, const char*>::const_iterator it = _NullsOption_VALUES_TO_NAMES.find(val);
  if (it != _NullsOption_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NullsOption::type& val) {
  std::map<int, const char*>::const_iterator it = _NullsOption_VALUES_TO_NAMES.find(val);
  if (it != _NullsOption_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kExprOptionValues[] = {
  ExprOption::LITERAL,
  ExprOption::COLUMN,
  ExprOption::EXPR
};
const char* _kExprOptionNames[] = {
  "LITERAL",
  "COLUMN",
  "EXPR"
};
const std::map<int, const char*> _ExprOption_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kExprOptionValues, _kExprOptionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExprOption::type& val) {
  std::map<int, const char*>::const_iterator it = _ExprOption_VALUES_TO_NAMES.find(val);
  if (it != _ExprOption_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExprOption::type& val) {
  std::map<int, const char*>::const_iterator it = _ExprOption_VALUES_TO_NAMES.find(val);
  if (it != _ExprOption_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLiteralOptionValues[] = {
  LiteralOption::LITERAL,
  LiteralOption::RANGE
};
const char* _kLiteralOptionNames[] = {
  "LITERAL",
  "RANGE"
};
const std::map<int, const char*> _LiteralOption_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLiteralOptionValues, _kLiteralOptionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LiteralOption::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralOption_VALUES_TO_NAMES.find(val);
  if (it != _LiteralOption_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LiteralOption::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralOption_VALUES_TO_NAMES.find(val);
  if (it != _LiteralOption_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


CollationType::~CollationType() noexcept {
}

CollationType::CollationType() noexcept
   : field(0),
     direction(static_cast<DirectionOption::type>(0)),
     nulls(static_cast<NullsOption::type>(0)) {
}

void CollationType::__set_field(const int64_t val) {
  this->field = val;
}

void CollationType::__set_direction(const DirectionOption::type val) {
  this->direction = val;
}

void CollationType::__set_nulls(const NullsOption::type val) {
  this->nulls = val;
}
std::ostream& operator<<(std::ostream& out, const CollationType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CollationType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->field);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->direction = static_cast<DirectionOption::type>(ecast0);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->nulls = static_cast<NullsOption::type>(ecast1);
          this->__isset.nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CollationType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CollationType");

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->direction));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->nulls));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CollationType &a, CollationType &b) {
  using ::std::swap;
  swap(a.field, b.field);
  swap(a.direction, b.direction);
  swap(a.nulls, b.nulls);
  swap(a.__isset, b.__isset);
}

bool CollationType::operator==(const CollationType & rhs) const
{
  if (!(field == rhs.field))
    return false;
  if (!(direction == rhs.direction))
    return false;
  if (!(nulls == rhs.nulls))
    return false;
  return true;
}

CollationType::CollationType(const CollationType& other2) noexcept {
  field = other2.field;
  direction = other2.direction;
  nulls = other2.nulls;
  __isset = other2.__isset;
}
CollationType& CollationType::operator=(const CollationType& other3) noexcept {
  field = other3.field;
  direction = other3.direction;
  nulls = other3.nulls;
  __isset = other3.__isset;
  return *this;
}
void CollationType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CollationType(";
  out << "field=" << to_string(field);
  out << ", " << "direction=" << to_string(direction);
  out << ", " << "nulls=" << to_string(nulls);
  out << ")";
}


AggType::~AggType() noexcept {
}

AggType::AggType() noexcept
   : agg(),
     name(),
     type(),
     distinct(0) {
}

void AggType::__set_agg(const std::string& val) {
  this->agg = val;
}

void AggType::__set_operands(const std::vector<int64_t> & val) {
  this->operands = val;
}

void AggType::__set_name(const std::string& val) {
  this->name = val;
}

void AggType::__set_type(const std::string& val) {
  this->type = val;
}

void AggType::__set_distinct(const bool val) {
  this->distinct = val;
}
std::ostream& operator<<(std::ostream& out, const AggType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AggType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agg);
          this->__isset.agg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operands.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->operands.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readI64(this->operands[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operands = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->distinct);
          this->__isset.distinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AggType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AggType");

  xfer += oprot->writeFieldBegin("agg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->agg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operands", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->operands.size()));
    std::vector<int64_t> ::const_iterator _iter9;
    for (_iter9 = this->operands.begin(); _iter9 != this->operands.end(); ++_iter9)
    {
      xfer += oprot->writeI64((*_iter9));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("distinct", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->distinct);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AggType &a, AggType &b) {
  using ::std::swap;
  swap(a.agg, b.agg);
  swap(a.operands, b.operands);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.distinct, b.distinct);
  swap(a.__isset, b.__isset);
}

bool AggType::operator==(const AggType & rhs) const
{
  if (!(agg == rhs.agg))
    return false;
  if (!(operands == rhs.operands))
    return false;
  if (!(name == rhs.name))
    return false;
  if (!(type == rhs.type))
    return false;
  if (!(distinct == rhs.distinct))
    return false;
  return true;
}

AggType::AggType(const AggType& other10) {
  agg = other10.agg;
  operands = other10.operands;
  name = other10.name;
  type = other10.type;
  distinct = other10.distinct;
  __isset = other10.__isset;
}
AggType& AggType::operator=(const AggType& other11) {
  agg = other11.agg;
  operands = other11.operands;
  name = other11.name;
  type = other11.type;
  distinct = other11.distinct;
  __isset = other11.__isset;
  return *this;
}
void AggType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AggType(";
  out << "agg=" << to_string(agg);
  out << ", " << "operands=" << to_string(operands);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "distinct=" << to_string(distinct);
  out << ")";
}


LiteralType::~LiteralType() noexcept {
}

LiteralType::LiteralType() noexcept
   : literalOption(static_cast<LiteralOption::type>(0)),
     value(0) {
}

void LiteralType::__set_literalOption(const LiteralOption::type val) {
  this->literalOption = val;
}

void LiteralType::__set_value(const int64_t val) {
  this->value = val;
__isset.value = true;
}

void LiteralType::__set_rangeSet(const std::vector<std::vector<std::string> > & val) {
  this->rangeSet = val;
__isset.rangeSet = true;
}
std::ostream& operator<<(std::ostream& out, const LiteralType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LiteralType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->literalOption = static_cast<LiteralOption::type>(ecast12);
          this->__isset.literalOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rangeSet.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->rangeSet.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              {
                this->rangeSet[_i17].clear();
                uint32_t _size18;
                ::apache::thrift::protocol::TType _etype21;
                xfer += iprot->readListBegin(_etype21, _size18);
                this->rangeSet[_i17].resize(_size18);
                uint32_t _i22;
                for (_i22 = 0; _i22 < _size18; ++_i22)
                {
                  xfer += iprot->readString(this->rangeSet[_i17][_i22]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rangeSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LiteralType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LiteralType");

  xfer += oprot->writeFieldBegin("literalOption", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->literalOption));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rangeSet) {
    xfer += oprot->writeFieldBegin("rangeSet", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rangeSet.size()));
      std::vector<std::vector<std::string> > ::const_iterator _iter23;
      for (_iter23 = this->rangeSet.begin(); _iter23 != this->rangeSet.end(); ++_iter23)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter23).size()));
          std::vector<std::string> ::const_iterator _iter24;
          for (_iter24 = (*_iter23).begin(); _iter24 != (*_iter23).end(); ++_iter24)
          {
            xfer += oprot->writeString((*_iter24));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LiteralType &a, LiteralType &b) {
  using ::std::swap;
  swap(a.literalOption, b.literalOption);
  swap(a.value, b.value);
  swap(a.rangeSet, b.rangeSet);
  swap(a.__isset, b.__isset);
}

bool LiteralType::operator==(const LiteralType & rhs) const
{
  if (!(literalOption == rhs.literalOption))
    return false;
  if (__isset.value != rhs.__isset.value)
    return false;
  else if (__isset.value && !(value == rhs.value))
    return false;
  if (__isset.rangeSet != rhs.__isset.rangeSet)
    return false;
  else if (__isset.rangeSet && !(rangeSet == rhs.rangeSet))
    return false;
  return true;
}

LiteralType::LiteralType(const LiteralType& other25) {
  literalOption = other25.literalOption;
  value = other25.value;
  rangeSet = other25.rangeSet;
  __isset = other25.__isset;
}
LiteralType& LiteralType::operator=(const LiteralType& other26) {
  literalOption = other26.literalOption;
  value = other26.value;
  rangeSet = other26.rangeSet;
  __isset = other26.__isset;
  return *this;
}
void LiteralType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LiteralType(";
  out << "literalOption=" << to_string(literalOption);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "rangeSet="; (__isset.rangeSet ? (out << to_string(rangeSet)) : (out << "<null>"));
  out << ")";
}


ExprType::~ExprType() noexcept {
}

ExprType::ExprType() noexcept
   : exprType(static_cast<ExprOption::type>(0)),
     input(0),
     name(),
     op(),
     type() {
}

void ExprType::__set_exprType(const ExprOption::type val) {
  this->exprType = val;
}

void ExprType::__set_input(const int64_t val) {
  this->input = val;
__isset.input = true;
}

void ExprType::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void ExprType::__set_op(const std::string& val) {
  this->op = val;
__isset.op = true;
}

void ExprType::__set_operands(const std::vector<ExprType> & val) {
  this->operands = val;
__isset.operands = true;
}

void ExprType::__set_literal(const LiteralType& val) {
  this->literal = val;
__isset.literal = true;
}

void ExprType::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const ExprType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExprType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast27;
          xfer += iprot->readI32(ecast27);
          this->exprType = static_cast<ExprOption::type>(ecast27);
          this->__isset.exprType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->input);
          this->__isset.input = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->op);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operands.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->operands.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->operands[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operands = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->literal.read(iprot);
          this->__isset.literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExprType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExprType");

  xfer += oprot->writeFieldBegin("exprType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->exprType));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.input) {
    xfer += oprot->writeFieldBegin("input", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->input);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.op) {
    xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->op);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operands) {
    xfer += oprot->writeFieldBegin("operands", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->operands.size()));
      std::vector<ExprType> ::const_iterator _iter33;
      for (_iter33 = this->operands.begin(); _iter33 != this->operands.end(); ++_iter33)
      {
        xfer += (*_iter33).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.literal) {
    xfer += oprot->writeFieldBegin("literal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExprType &a, ExprType &b) {
  using ::std::swap;
  swap(a.exprType, b.exprType);
  swap(a.input, b.input);
  swap(a.name, b.name);
  swap(a.op, b.op);
  swap(a.operands, b.operands);
  swap(a.literal, b.literal);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

bool ExprType::operator==(const ExprType & rhs) const
{
  if (!(exprType == rhs.exprType))
    return false;
  if (__isset.input != rhs.__isset.input)
    return false;
  else if (__isset.input && !(input == rhs.input))
    return false;
  if (__isset.name != rhs.__isset.name)
    return false;
  else if (__isset.name && !(name == rhs.name))
    return false;
  if (__isset.op != rhs.__isset.op)
    return false;
  else if (__isset.op && !(op == rhs.op))
    return false;
  if (__isset.operands != rhs.__isset.operands)
    return false;
  else if (__isset.operands && !(operands == rhs.operands))
    return false;
  if (__isset.literal != rhs.__isset.literal)
    return false;
  else if (__isset.literal && !(literal == rhs.literal))
    return false;
  if (__isset.type != rhs.__isset.type)
    return false;
  else if (__isset.type && !(type == rhs.type))
    return false;
  return true;
}

ExprType::ExprType(const ExprType& other34) {
  exprType = other34.exprType;
  input = other34.input;
  name = other34.name;
  op = other34.op;
  operands = other34.operands;
  literal = other34.literal;
  type = other34.type;
  __isset = other34.__isset;
}
ExprType& ExprType::operator=(const ExprType& other35) {
  exprType = other35.exprType;
  input = other35.input;
  name = other35.name;
  op = other35.op;
  operands = other35.operands;
  literal = other35.literal;
  type = other35.type;
  __isset = other35.__isset;
  return *this;
}
void ExprType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExprType(";
  out << "exprType=" << to_string(exprType);
  out << ", " << "input="; (__isset.input ? (out << to_string(input)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "op="; (__isset.op ? (out << to_string(op)) : (out << "<null>"));
  out << ", " << "operands="; (__isset.operands ? (out << to_string(operands)) : (out << "<null>"));
  out << ", " << "literal="; (__isset.literal ? (out << to_string(literal)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


RelNode::~RelNode() noexcept {
}

RelNode::RelNode() noexcept
   : id(0),
     relOp(static_cast<RelNodeType::type>(0)),
     joinType() {
}

void RelNode::__set_id(const int64_t val) {
  this->id = val;
}

void RelNode::__set_relOp(const RelNodeType::type val) {
  this->relOp = val;
}

void RelNode::__set_tables(const std::vector<std::string> & val) {
  this->tables = val;
__isset.tables = true;
}

void RelNode::__set_inputs(const std::vector<int64_t> & val) {
  this->inputs = val;
__isset.inputs = true;
}

void RelNode::__set_condition(const ExprType& val) {
  this->condition = val;
__isset.condition = true;
}

void RelNode::__set_joinType(const std::string& val) {
  this->joinType = val;
__isset.joinType = true;
}

void RelNode::__set_fields(const std::vector<std::string> & val) {
  this->fields = val;
__isset.fields = true;
}

void RelNode::__set_exprs(const std::vector<ExprType> & val) {
  this->exprs = val;
__isset.exprs = true;
}

void RelNode::__set_group(const std::vector<int64_t> & val) {
  this->group = val;
__isset.group = true;
}

void RelNode::__set_aggs(const std::vector<AggType> & val) {
  this->aggs = val;
__isset.aggs = true;
}

void RelNode::__set_collation(const std::vector<CollationType> & val) {
  this->collation = val;
__isset.collation = true;
}
std::ostream& operator<<(std::ostream& out, const RelNode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RelNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast36;
          xfer += iprot->readI32(ecast36);
          this->relOp = static_cast<RelNodeType::type>(ecast36);
          this->__isset.relOp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->tables.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readString(this->tables[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputs.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->inputs.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readI64(this->inputs[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->condition.read(iprot);
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->joinType);
          this->__isset.joinType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->fields.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readString(this->fields[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exprs.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->exprs.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->exprs[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->group.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += iprot->readI64(this->group[_i61]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggs.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->aggs.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->aggs[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aggs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->collation.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->collation.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->collation[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.collation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RelNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RelNode");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relOp", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->relOp));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tables) {
    xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
      std::vector<std::string> ::const_iterator _iter72;
      for (_iter72 = this->tables.begin(); _iter72 != this->tables.end(); ++_iter72)
      {
        xfer += oprot->writeString((*_iter72));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inputs) {
    xfer += oprot->writeFieldBegin("inputs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->inputs.size()));
      std::vector<int64_t> ::const_iterator _iter73;
      for (_iter73 = this->inputs.begin(); _iter73 != this->inputs.end(); ++_iter73)
      {
        xfer += oprot->writeI64((*_iter73));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.condition) {
    xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->condition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.joinType) {
    xfer += oprot->writeFieldBegin("joinType", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->joinType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fields.size()));
      std::vector<std::string> ::const_iterator _iter74;
      for (_iter74 = this->fields.begin(); _iter74 != this->fields.end(); ++_iter74)
      {
        xfer += oprot->writeString((*_iter74));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exprs) {
    xfer += oprot->writeFieldBegin("exprs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exprs.size()));
      std::vector<ExprType> ::const_iterator _iter75;
      for (_iter75 = this->exprs.begin(); _iter75 != this->exprs.end(); ++_iter75)
      {
        xfer += (*_iter75).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group) {
    xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->group.size()));
      std::vector<int64_t> ::const_iterator _iter76;
      for (_iter76 = this->group.begin(); _iter76 != this->group.end(); ++_iter76)
      {
        xfer += oprot->writeI64((*_iter76));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggs) {
    xfer += oprot->writeFieldBegin("aggs", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggs.size()));
      std::vector<AggType> ::const_iterator _iter77;
      for (_iter77 = this->aggs.begin(); _iter77 != this->aggs.end(); ++_iter77)
      {
        xfer += (*_iter77).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.collation) {
    xfer += oprot->writeFieldBegin("collation", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->collation.size()));
      std::vector<CollationType> ::const_iterator _iter78;
      for (_iter78 = this->collation.begin(); _iter78 != this->collation.end(); ++_iter78)
      {
        xfer += (*_iter78).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RelNode &a, RelNode &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.relOp, b.relOp);
  swap(a.tables, b.tables);
  swap(a.inputs, b.inputs);
  swap(a.condition, b.condition);
  swap(a.joinType, b.joinType);
  swap(a.fields, b.fields);
  swap(a.exprs, b.exprs);
  swap(a.group, b.group);
  swap(a.aggs, b.aggs);
  swap(a.collation, b.collation);
  swap(a.__isset, b.__isset);
}

bool RelNode::operator==(const RelNode & rhs) const
{
  if (!(id == rhs.id))
    return false;
  if (!(relOp == rhs.relOp))
    return false;
  if (__isset.tables != rhs.__isset.tables)
    return false;
  else if (__isset.tables && !(tables == rhs.tables))
    return false;
  if (__isset.inputs != rhs.__isset.inputs)
    return false;
  else if (__isset.inputs && !(inputs == rhs.inputs))
    return false;
  if (__isset.condition != rhs.__isset.condition)
    return false;
  else if (__isset.condition && !(condition == rhs.condition))
    return false;
  if (__isset.joinType != rhs.__isset.joinType)
    return false;
  else if (__isset.joinType && !(joinType == rhs.joinType))
    return false;
  if (__isset.fields != rhs.__isset.fields)
    return false;
  else if (__isset.fields && !(fields == rhs.fields))
    return false;
  if (__isset.exprs != rhs.__isset.exprs)
    return false;
  else if (__isset.exprs && !(exprs == rhs.exprs))
    return false;
  if (__isset.group != rhs.__isset.group)
    return false;
  else if (__isset.group && !(group == rhs.group))
    return false;
  if (__isset.aggs != rhs.__isset.aggs)
    return false;
  else if (__isset.aggs && !(aggs == rhs.aggs))
    return false;
  if (__isset.collation != rhs.__isset.collation)
    return false;
  else if (__isset.collation && !(collation == rhs.collation))
    return false;
  return true;
}

RelNode::RelNode(const RelNode& other79) {
  id = other79.id;
  relOp = other79.relOp;
  tables = other79.tables;
  inputs = other79.inputs;
  condition = other79.condition;
  joinType = other79.joinType;
  fields = other79.fields;
  exprs = other79.exprs;
  group = other79.group;
  aggs = other79.aggs;
  collation = other79.collation;
  __isset = other79.__isset;
}
RelNode& RelNode::operator=(const RelNode& other80) {
  id = other80.id;
  relOp = other80.relOp;
  tables = other80.tables;
  inputs = other80.inputs;
  condition = other80.condition;
  joinType = other80.joinType;
  fields = other80.fields;
  exprs = other80.exprs;
  group = other80.group;
  aggs = other80.aggs;
  collation = other80.collation;
  __isset = other80.__isset;
  return *this;
}
void RelNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RelNode(";
  out << "id=" << to_string(id);
  out << ", " << "relOp=" << to_string(relOp);
  out << ", " << "tables="; (__isset.tables ? (out << to_string(tables)) : (out << "<null>"));
  out << ", " << "inputs="; (__isset.inputs ? (out << to_string(inputs)) : (out << "<null>"));
  out << ", " << "condition="; (__isset.condition ? (out << to_string(condition)) : (out << "<null>"));
  out << ", " << "joinType="; (__isset.joinType ? (out << to_string(joinType)) : (out << "<null>"));
  out << ", " << "fields="; (__isset.fields ? (out << to_string(fields)) : (out << "<null>"));
  out << ", " << "exprs="; (__isset.exprs ? (out << to_string(exprs)) : (out << "<null>"));
  out << ", " << "group="; (__isset.group ? (out << to_string(group)) : (out << "<null>"));
  out << ", " << "aggs="; (__isset.aggs ? (out << to_string(aggs)) : (out << "<null>"));
  out << ", " << "collation="; (__isset.collation ? (out << to_string(collation)) : (out << "<null>"));
  out << ")";
}


PlanResult::~PlanResult() noexcept {
}

PlanResult::PlanResult() noexcept
   : oldJson() {
}

void PlanResult::__set_rels(const std::vector<RelNode> & val) {
  this->rels = val;
}

void PlanResult::__set_oldJson(const std::string& val) {
  this->oldJson = val;
}
std::ostream& operator<<(std::ostream& out, const PlanResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PlanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rels.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readListBegin(_etype84, _size81);
            this->rels.resize(_size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              xfer += this->rels[_i85].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oldJson);
          this->__isset.oldJson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlanResult");

  xfer += oprot->writeFieldBegin("rels", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rels.size()));
    std::vector<RelNode> ::const_iterator _iter86;
    for (_iter86 = this->rels.begin(); _iter86 != this->rels.end(); ++_iter86)
    {
      xfer += (*_iter86).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oldJson", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->oldJson);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlanResult &a, PlanResult &b) {
  using ::std::swap;
  swap(a.rels, b.rels);
  swap(a.oldJson, b.oldJson);
  swap(a.__isset, b.__isset);
}

bool PlanResult::operator==(const PlanResult & rhs) const
{
  if (!(rels == rhs.rels))
    return false;
  if (!(oldJson == rhs.oldJson))
    return false;
  return true;
}

PlanResult::PlanResult(const PlanResult& other87) {
  rels = other87.rels;
  oldJson = other87.oldJson;
  __isset = other87.__isset;
}
PlanResult& PlanResult::operator=(const PlanResult& other88) {
  rels = other88.rels;
  oldJson = other88.oldJson;
  __isset = other88.__isset;
  return *this;
}
void PlanResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlanResult(";
  out << "rels=" << to_string(rels);
  out << ", " << "oldJson=" << to_string(oldJson);
  out << ")";
}


