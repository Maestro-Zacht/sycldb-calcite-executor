/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "calciteserver_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kRelNodeTypeValues[] = {
  RelNodeType::TABLE_SCAN,
  RelNodeType::FILTER,
  RelNodeType::JOIN,
  RelNodeType::PROJECT,
  RelNodeType::AGGREGATE
};
const char* _kRelNodeTypeNames[] = {
  "TABLE_SCAN",
  "FILTER",
  "JOIN",
  "PROJECT",
  "AGGREGATE"
};
const std::map<int, const char*> _RelNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kRelNodeTypeValues, _kRelNodeTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const RelNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _RelNodeType_VALUES_TO_NAMES.find(val);
  if (it != _RelNodeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const RelNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _RelNodeType_VALUES_TO_NAMES.find(val);
  if (it != _RelNodeType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kExprOptionValues[] = {
  ExprOption::LITERAL,
  ExprOption::COLUMN,
  ExprOption::EXPR
};
const char* _kExprOptionNames[] = {
  "LITERAL",
  "COLUMN",
  "EXPR"
};
const std::map<int, const char*> _ExprOption_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kExprOptionValues, _kExprOptionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExprOption::type& val) {
  std::map<int, const char*>::const_iterator it = _ExprOption_VALUES_TO_NAMES.find(val);
  if (it != _ExprOption_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExprOption::type& val) {
  std::map<int, const char*>::const_iterator it = _ExprOption_VALUES_TO_NAMES.find(val);
  if (it != _ExprOption_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLiteralOptionValues[] = {
  LiteralOption::LITERAL,
  LiteralOption::RANGE
};
const char* _kLiteralOptionNames[] = {
  "LITERAL",
  "RANGE"
};
const std::map<int, const char*> _LiteralOption_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLiteralOptionValues, _kLiteralOptionNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LiteralOption::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralOption_VALUES_TO_NAMES.find(val);
  if (it != _LiteralOption_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LiteralOption::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralOption_VALUES_TO_NAMES.find(val);
  if (it != _LiteralOption_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


AggType::~AggType() noexcept {
}

AggType::AggType() noexcept
   : agg(),
     name(),
     type(),
     distinct(0) {
}

void AggType::__set_agg(const std::string& val) {
  this->agg = val;
}

void AggType::__set_operands(const std::vector<int64_t> & val) {
  this->operands = val;
}

void AggType::__set_name(const std::string& val) {
  this->name = val;
}

void AggType::__set_type(const std::string& val) {
  this->type = val;
}

void AggType::__set_distinct(const bool val) {
  this->distinct = val;
}
std::ostream& operator<<(std::ostream& out, const AggType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AggType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agg);
          this->__isset.agg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operands.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->operands.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI64(this->operands[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operands = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->distinct);
          this->__isset.distinct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AggType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AggType");

  xfer += oprot->writeFieldBegin("agg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->agg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operands", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->operands.size()));
    std::vector<int64_t> ::const_iterator _iter5;
    for (_iter5 = this->operands.begin(); _iter5 != this->operands.end(); ++_iter5)
    {
      xfer += oprot->writeI64((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("distinct", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->distinct);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AggType &a, AggType &b) {
  using ::std::swap;
  swap(a.agg, b.agg);
  swap(a.operands, b.operands);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.distinct, b.distinct);
  swap(a.__isset, b.__isset);
}

bool AggType::operator==(const AggType & rhs) const
{
  if (!(agg == rhs.agg))
    return false;
  if (!(operands == rhs.operands))
    return false;
  if (!(name == rhs.name))
    return false;
  if (!(type == rhs.type))
    return false;
  if (!(distinct == rhs.distinct))
    return false;
  return true;
}

AggType::AggType(const AggType& other6) {
  agg = other6.agg;
  operands = other6.operands;
  name = other6.name;
  type = other6.type;
  distinct = other6.distinct;
  __isset = other6.__isset;
}
AggType& AggType::operator=(const AggType& other7) {
  agg = other7.agg;
  operands = other7.operands;
  name = other7.name;
  type = other7.type;
  distinct = other7.distinct;
  __isset = other7.__isset;
  return *this;
}
void AggType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AggType(";
  out << "agg=" << to_string(agg);
  out << ", " << "operands=" << to_string(operands);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "distinct=" << to_string(distinct);
  out << ")";
}


LiteralType::~LiteralType() noexcept {
}

LiteralType::LiteralType() noexcept
   : literalOption(static_cast<LiteralOption::type>(0)),
     value(0) {
}

void LiteralType::__set_literalOption(const LiteralOption::type val) {
  this->literalOption = val;
}

void LiteralType::__set_value(const int64_t val) {
  this->value = val;
__isset.value = true;
}

void LiteralType::__set_rangeSet(const std::vector<std::vector<std::string> > & val) {
  this->rangeSet = val;
__isset.rangeSet = true;
}
std::ostream& operator<<(std::ostream& out, const LiteralType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LiteralType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->literalOption = static_cast<LiteralOption::type>(ecast8);
          this->__isset.literalOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rangeSet.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->rangeSet.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              {
                this->rangeSet[_i13].clear();
                uint32_t _size14;
                ::apache::thrift::protocol::TType _etype17;
                xfer += iprot->readListBegin(_etype17, _size14);
                this->rangeSet[_i13].resize(_size14);
                uint32_t _i18;
                for (_i18 = 0; _i18 < _size14; ++_i18)
                {
                  xfer += iprot->readString(this->rangeSet[_i13][_i18]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rangeSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LiteralType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LiteralType");

  xfer += oprot->writeFieldBegin("literalOption", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->literalOption));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rangeSet) {
    xfer += oprot->writeFieldBegin("rangeSet", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rangeSet.size()));
      std::vector<std::vector<std::string> > ::const_iterator _iter19;
      for (_iter19 = this->rangeSet.begin(); _iter19 != this->rangeSet.end(); ++_iter19)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter19).size()));
          std::vector<std::string> ::const_iterator _iter20;
          for (_iter20 = (*_iter19).begin(); _iter20 != (*_iter19).end(); ++_iter20)
          {
            xfer += oprot->writeString((*_iter20));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LiteralType &a, LiteralType &b) {
  using ::std::swap;
  swap(a.literalOption, b.literalOption);
  swap(a.value, b.value);
  swap(a.rangeSet, b.rangeSet);
  swap(a.__isset, b.__isset);
}

bool LiteralType::operator==(const LiteralType & rhs) const
{
  if (!(literalOption == rhs.literalOption))
    return false;
  if (__isset.value != rhs.__isset.value)
    return false;
  else if (__isset.value && !(value == rhs.value))
    return false;
  if (__isset.rangeSet != rhs.__isset.rangeSet)
    return false;
  else if (__isset.rangeSet && !(rangeSet == rhs.rangeSet))
    return false;
  return true;
}

LiteralType::LiteralType(const LiteralType& other21) {
  literalOption = other21.literalOption;
  value = other21.value;
  rangeSet = other21.rangeSet;
  __isset = other21.__isset;
}
LiteralType& LiteralType::operator=(const LiteralType& other22) {
  literalOption = other22.literalOption;
  value = other22.value;
  rangeSet = other22.rangeSet;
  __isset = other22.__isset;
  return *this;
}
void LiteralType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LiteralType(";
  out << "literalOption=" << to_string(literalOption);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "rangeSet="; (__isset.rangeSet ? (out << to_string(rangeSet)) : (out << "<null>"));
  out << ")";
}


ExprType::~ExprType() noexcept {
}

ExprType::ExprType() noexcept
   : exprType(static_cast<ExprOption::type>(0)),
     input(0),
     name(),
     op(),
     type() {
}

void ExprType::__set_exprType(const ExprOption::type val) {
  this->exprType = val;
}

void ExprType::__set_input(const int64_t val) {
  this->input = val;
__isset.input = true;
}

void ExprType::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void ExprType::__set_op(const std::string& val) {
  this->op = val;
__isset.op = true;
}

void ExprType::__set_operands(const std::vector<ExprType> & val) {
  this->operands = val;
__isset.operands = true;
}

void ExprType::__set_literal(const LiteralType& val) {
  this->literal = val;
__isset.literal = true;
}

void ExprType::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const ExprType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExprType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          this->exprType = static_cast<ExprOption::type>(ecast23);
          this->__isset.exprType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->input);
          this->__isset.input = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->op);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operands.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->operands.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->operands[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operands = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->literal.read(iprot);
          this->__isset.literal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExprType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExprType");

  xfer += oprot->writeFieldBegin("exprType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->exprType));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.input) {
    xfer += oprot->writeFieldBegin("input", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->input);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.op) {
    xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->op);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operands) {
    xfer += oprot->writeFieldBegin("operands", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->operands.size()));
      std::vector<ExprType> ::const_iterator _iter29;
      for (_iter29 = this->operands.begin(); _iter29 != this->operands.end(); ++_iter29)
      {
        xfer += (*_iter29).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.literal) {
    xfer += oprot->writeFieldBegin("literal", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->literal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExprType &a, ExprType &b) {
  using ::std::swap;
  swap(a.exprType, b.exprType);
  swap(a.input, b.input);
  swap(a.name, b.name);
  swap(a.op, b.op);
  swap(a.operands, b.operands);
  swap(a.literal, b.literal);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

bool ExprType::operator==(const ExprType & rhs) const
{
  if (!(exprType == rhs.exprType))
    return false;
  if (__isset.input != rhs.__isset.input)
    return false;
  else if (__isset.input && !(input == rhs.input))
    return false;
  if (__isset.name != rhs.__isset.name)
    return false;
  else if (__isset.name && !(name == rhs.name))
    return false;
  if (__isset.op != rhs.__isset.op)
    return false;
  else if (__isset.op && !(op == rhs.op))
    return false;
  if (__isset.operands != rhs.__isset.operands)
    return false;
  else if (__isset.operands && !(operands == rhs.operands))
    return false;
  if (__isset.literal != rhs.__isset.literal)
    return false;
  else if (__isset.literal && !(literal == rhs.literal))
    return false;
  if (__isset.type != rhs.__isset.type)
    return false;
  else if (__isset.type && !(type == rhs.type))
    return false;
  return true;
}

ExprType::ExprType(const ExprType& other30) {
  exprType = other30.exprType;
  input = other30.input;
  name = other30.name;
  op = other30.op;
  operands = other30.operands;
  literal = other30.literal;
  type = other30.type;
  __isset = other30.__isset;
}
ExprType& ExprType::operator=(const ExprType& other31) {
  exprType = other31.exprType;
  input = other31.input;
  name = other31.name;
  op = other31.op;
  operands = other31.operands;
  literal = other31.literal;
  type = other31.type;
  __isset = other31.__isset;
  return *this;
}
void ExprType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExprType(";
  out << "exprType=" << to_string(exprType);
  out << ", " << "input="; (__isset.input ? (out << to_string(input)) : (out << "<null>"));
  out << ", " << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "op="; (__isset.op ? (out << to_string(op)) : (out << "<null>"));
  out << ", " << "operands="; (__isset.operands ? (out << to_string(operands)) : (out << "<null>"));
  out << ", " << "literal="; (__isset.literal ? (out << to_string(literal)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


RelNode::~RelNode() noexcept {
}

RelNode::RelNode() noexcept
   : id(0),
     relOp(static_cast<RelNodeType::type>(0)),
     joinType() {
}

void RelNode::__set_id(const int64_t val) {
  this->id = val;
}

void RelNode::__set_relOp(const RelNodeType::type val) {
  this->relOp = val;
}

void RelNode::__set_tables(const std::vector<std::string> & val) {
  this->tables = val;
__isset.tables = true;
}

void RelNode::__set_inputs(const std::vector<int64_t> & val) {
  this->inputs = val;
__isset.inputs = true;
}

void RelNode::__set_condition(const ExprType& val) {
  this->condition = val;
__isset.condition = true;
}

void RelNode::__set_joinType(const std::string& val) {
  this->joinType = val;
__isset.joinType = true;
}

void RelNode::__set_fields(const std::vector<std::string> & val) {
  this->fields = val;
__isset.fields = true;
}

void RelNode::__set_exprs(const std::vector<ExprType> & val) {
  this->exprs = val;
__isset.exprs = true;
}

void RelNode::__set_group(const std::vector<int64_t> & val) {
  this->group = val;
__isset.group = true;
}

void RelNode::__set_aggs(const std::vector<AggType> & val) {
  this->aggs = val;
__isset.aggs = true;
}
std::ostream& operator<<(std::ostream& out, const RelNode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RelNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->relOp = static_cast<RelNodeType::type>(ecast32);
          this->__isset.relOp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->tables.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += iprot->readString(this->tables[_i37]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->inputs.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->inputs.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readI64(this->inputs[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.inputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->condition.read(iprot);
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->joinType);
          this->__isset.joinType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->fields.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readString(this->fields[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exprs.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->exprs.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += this->exprs[_i52].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->group.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readI64(this->group[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggs.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->aggs.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += this->aggs[_i62].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aggs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RelNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RelNode");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("relOp", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->relOp));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tables) {
    xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
      std::vector<std::string> ::const_iterator _iter63;
      for (_iter63 = this->tables.begin(); _iter63 != this->tables.end(); ++_iter63)
      {
        xfer += oprot->writeString((*_iter63));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.inputs) {
    xfer += oprot->writeFieldBegin("inputs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->inputs.size()));
      std::vector<int64_t> ::const_iterator _iter64;
      for (_iter64 = this->inputs.begin(); _iter64 != this->inputs.end(); ++_iter64)
      {
        xfer += oprot->writeI64((*_iter64));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.condition) {
    xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->condition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.joinType) {
    xfer += oprot->writeFieldBegin("joinType", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->joinType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fields) {
    xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fields.size()));
      std::vector<std::string> ::const_iterator _iter65;
      for (_iter65 = this->fields.begin(); _iter65 != this->fields.end(); ++_iter65)
      {
        xfer += oprot->writeString((*_iter65));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exprs) {
    xfer += oprot->writeFieldBegin("exprs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exprs.size()));
      std::vector<ExprType> ::const_iterator _iter66;
      for (_iter66 = this->exprs.begin(); _iter66 != this->exprs.end(); ++_iter66)
      {
        xfer += (*_iter66).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group) {
    xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->group.size()));
      std::vector<int64_t> ::const_iterator _iter67;
      for (_iter67 = this->group.begin(); _iter67 != this->group.end(); ++_iter67)
      {
        xfer += oprot->writeI64((*_iter67));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aggs) {
    xfer += oprot->writeFieldBegin("aggs", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggs.size()));
      std::vector<AggType> ::const_iterator _iter68;
      for (_iter68 = this->aggs.begin(); _iter68 != this->aggs.end(); ++_iter68)
      {
        xfer += (*_iter68).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RelNode &a, RelNode &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.relOp, b.relOp);
  swap(a.tables, b.tables);
  swap(a.inputs, b.inputs);
  swap(a.condition, b.condition);
  swap(a.joinType, b.joinType);
  swap(a.fields, b.fields);
  swap(a.exprs, b.exprs);
  swap(a.group, b.group);
  swap(a.aggs, b.aggs);
  swap(a.__isset, b.__isset);
}

bool RelNode::operator==(const RelNode & rhs) const
{
  if (!(id == rhs.id))
    return false;
  if (!(relOp == rhs.relOp))
    return false;
  if (__isset.tables != rhs.__isset.tables)
    return false;
  else if (__isset.tables && !(tables == rhs.tables))
    return false;
  if (__isset.inputs != rhs.__isset.inputs)
    return false;
  else if (__isset.inputs && !(inputs == rhs.inputs))
    return false;
  if (__isset.condition != rhs.__isset.condition)
    return false;
  else if (__isset.condition && !(condition == rhs.condition))
    return false;
  if (__isset.joinType != rhs.__isset.joinType)
    return false;
  else if (__isset.joinType && !(joinType == rhs.joinType))
    return false;
  if (__isset.fields != rhs.__isset.fields)
    return false;
  else if (__isset.fields && !(fields == rhs.fields))
    return false;
  if (__isset.exprs != rhs.__isset.exprs)
    return false;
  else if (__isset.exprs && !(exprs == rhs.exprs))
    return false;
  if (__isset.group != rhs.__isset.group)
    return false;
  else if (__isset.group && !(group == rhs.group))
    return false;
  if (__isset.aggs != rhs.__isset.aggs)
    return false;
  else if (__isset.aggs && !(aggs == rhs.aggs))
    return false;
  return true;
}

RelNode::RelNode(const RelNode& other69) {
  id = other69.id;
  relOp = other69.relOp;
  tables = other69.tables;
  inputs = other69.inputs;
  condition = other69.condition;
  joinType = other69.joinType;
  fields = other69.fields;
  exprs = other69.exprs;
  group = other69.group;
  aggs = other69.aggs;
  __isset = other69.__isset;
}
RelNode& RelNode::operator=(const RelNode& other70) {
  id = other70.id;
  relOp = other70.relOp;
  tables = other70.tables;
  inputs = other70.inputs;
  condition = other70.condition;
  joinType = other70.joinType;
  fields = other70.fields;
  exprs = other70.exprs;
  group = other70.group;
  aggs = other70.aggs;
  __isset = other70.__isset;
  return *this;
}
void RelNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RelNode(";
  out << "id=" << to_string(id);
  out << ", " << "relOp=" << to_string(relOp);
  out << ", " << "tables="; (__isset.tables ? (out << to_string(tables)) : (out << "<null>"));
  out << ", " << "inputs="; (__isset.inputs ? (out << to_string(inputs)) : (out << "<null>"));
  out << ", " << "condition="; (__isset.condition ? (out << to_string(condition)) : (out << "<null>"));
  out << ", " << "joinType="; (__isset.joinType ? (out << to_string(joinType)) : (out << "<null>"));
  out << ", " << "fields="; (__isset.fields ? (out << to_string(fields)) : (out << "<null>"));
  out << ", " << "exprs="; (__isset.exprs ? (out << to_string(exprs)) : (out << "<null>"));
  out << ", " << "group="; (__isset.group ? (out << to_string(group)) : (out << "<null>"));
  out << ", " << "aggs="; (__isset.aggs ? (out << to_string(aggs)) : (out << "<null>"));
  out << ")";
}


PlanResult::~PlanResult() noexcept {
}

PlanResult::PlanResult() noexcept
   : oldJson() {
}

void PlanResult::__set_rels(const std::vector<RelNode> & val) {
  this->rels = val;
}

void PlanResult::__set_oldJson(const std::string& val) {
  this->oldJson = val;
}
std::ostream& operator<<(std::ostream& out, const PlanResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PlanResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rels.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->rels.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->rels[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oldJson);
          this->__isset.oldJson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlanResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlanResult");

  xfer += oprot->writeFieldBegin("rels", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rels.size()));
    std::vector<RelNode> ::const_iterator _iter76;
    for (_iter76 = this->rels.begin(); _iter76 != this->rels.end(); ++_iter76)
    {
      xfer += (*_iter76).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oldJson", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->oldJson);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlanResult &a, PlanResult &b) {
  using ::std::swap;
  swap(a.rels, b.rels);
  swap(a.oldJson, b.oldJson);
  swap(a.__isset, b.__isset);
}

bool PlanResult::operator==(const PlanResult & rhs) const
{
  if (!(rels == rhs.rels))
    return false;
  if (!(oldJson == rhs.oldJson))
    return false;
  return true;
}

PlanResult::PlanResult(const PlanResult& other77) {
  rels = other77.rels;
  oldJson = other77.oldJson;
  __isset = other77.__isset;
}
PlanResult& PlanResult::operator=(const PlanResult& other78) {
  rels = other78.rels;
  oldJson = other78.oldJson;
  __isset = other78.__isset;
  return *this;
}
void PlanResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlanResult(";
  out << "rels=" << to_string(rels);
  out << ", " << "oldJson=" << to_string(oldJson);
  out << ")";
}


